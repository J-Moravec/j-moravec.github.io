---
title: "Make it `pop`!"
description: "Implementing stack behaviour in R"
date: "2024-3-11"
categories: [R]
toc: true
toc-depth: 4
---

Functions like `pop` exists in many languages for iterable item, such as lists or arrays.
While particulars change, in general `pop` removes an item from a container and return said item.
This is typical for data structures called `queue`, `stack`, and `deque`, which beside `pop` implement functions for adding elements to this container and differ in whether they are first in first out (queue), first in last out (stack), or both ways (deque).

While not common to R, these data structures are very convenient when you are consuming elements of an array, especially if the number of consumed elements can differ each iteration.
For instance, you can consume command-line arguments when each parameter can have different number of arguments.

## Setup

Let's have a vector `vec` containing a random integers, lets say `sample(1:10)`.
If the top element is odd, we remove one number, if it is even, we remove two numbers.
We note down these numbers.

```{r, eval = FALSE}
is_odd = function(x){
    x %% 2 != 0
    }

left = c()
right = c()
while(length(vec) > 0){
    if(is_odd(vec[1])){
        left = c(left, pop(vec, 1)
        } else {
        right = c(right, pop(vec, 2)
        }
    }
```

This is completely artificial example, but highlights one issue: Side effects of pop and the difficulty doing this in a vectorized way.

If we consumed only one element, we could easily write the operation as a for cycle:

```{r, eval = FALSE}
for(v in vec){
    if(is_odd(v)){
        do_something(v)
        } else {
        do_something_else(v)
        }
    }
```

But if we consume more than one element, this won't work.
Even if we replace iterating over `vec` with iterating over indices of vec:

```{r, eval = FALSE}
for(i in seq_along(vec)){
    ...
    }
```
Here `i = i + 1` won't work, since during each iteration `i` takes elements of `seq_along(vec)` and you can't skip item this way.
Unless you remember some `n_to_skip` variable:

```{r, eval = FALSE}
n_to_skip = 0
for(v in vec){
    if(n_to_skip > 0){
        n_to_skip = n_to_skip - 1
        next
        }

    if(is_odd(v)){
        do_something(v)
        } else {
        n_to_skip = n_to_skip + 1
        do_something_else(v)
        }
    }
```

but at least for me this feels very awkward.
On top of this, very convenient behaviour of the described `pop` function is that we can look at the current number of elements in the vector, this behaviour won't allow us to do so easily and the code is getting quite complicated.

## R `pop`

When doing modification of a state, the first thing that might come to your mind is the `<<-` operator. Sadly:

```{r, eval = FALSE}
pop = function(x){
    y = x[1]
    x <<- = x[-1]
    y
    }
```

will not work. What `<<-` is modifying is the `x` variable, not the variable that you are passing to `pop()`. For instance:

```{r, eval = FALSE}
vec = 1:3
pop(vec) # 1
vec # still 1:3
x # 2 3
```

You need to do a bit more magic to do that and get the name of the variable that stands for `x`.

```{r}
pop = function(x){
    ns = seq_along(x)

    val = x[ns]
    obj = x[-ns]

    assign(deparse(substitute(x)), obj, envir=parent.frame())
    val
    }

vec = 1:3
pop(vec) # 1
vec # 2 3
```

There are few potential issues here, we are assigning the value into the `parent.frame()` of the `pop` function, which won't work if the `pop` is being called inside function, but that is a risk I am willing to take and a version that I ended using.

## `pop` without memory reallocation

Another issue with the `pop` function above was that we are re-allocating the vector during each call `pop`.
This is not very efficient although for a lot of application, this is just fine.
But can we do better?

### Sideline: Memory address

### Saving position into attributes

### Environments

### C with `.Call`
