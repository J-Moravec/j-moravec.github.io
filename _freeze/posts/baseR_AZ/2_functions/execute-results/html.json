{
  "hash": "9bab1bc100a437741a7a6ae3283e5da0",
  "result": {
    "markdown": "---\ntitle: \"Base R from A to Z: Types of functions (2)\"\ndescription: \"Closures, primitives and internals\"\ndate: \"2023-02-25\"\ncategories: [R]\ntoc: true\ntoc-depth: 4\n---\n\n\n## Introduction\n\nIn the second part of the series about the base R, I wanted originally to talk about operators.\nBut to talk about properators properly, I wanted to explore how operators are defined first and the difference between classical functions and something called primitives. In the end, the *small segway* got a bit too big, so I decided to release it as an independent article.\n\n## Types of functions\n\n> To understand computations in R, two slogans are helpful:\n>\n> * Everything that exists is an object.\n> * Everything that happens is a function call.\n>\n>     -- John Chambers (author of S, coauthor of R)\n\nAs per the quote, everything that happens in R is a function call. Operators are construct similar to functions, but with special syntax or semantics.\nBut you might have realized that not every function is the same and that R has different types of functions.\n\nFor instance, when you write the name of a standard function, you will print their code.\nThis doesn't work with operators and other language elements. To operate with them, you need to escape them, either with quotation marks `\"` or backticks `` ` ``. Backticks typically work in most occassions. For instance, we can use backticks to print help of `+`, print the body of `-` or call `*` as if it was a function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?`+` # prints a help-page of +\n`-` # prints the body of -\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (e1, e2)  .Primitive(\"-\")\n```\n:::\n\n```{.r .cell-code}\n`*`(3,5) # call as if * was a normal function\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n:::\n\n\nOperators are special kind of functions, but so are other language elements like `for`, `return`, or in fact even `(` and `{`. But unlike with operators, calling language elements like a function doesn't work. We will talk about these language elements in detail some other time.\n\nThese special functions are called *primitives*. Primitives are special in many ways. Outside of primitives, all other functions are standard functions that either call R code, or call a compiled C or Fortran code through the interfaces `.Internal`, `.External`, `.C`, `.Call` or `.Fortran`.\n\nTo explore these function types in `base`, we will define a helper functions.\nAnd because there would be a lot of repeated code, we will construct these functions with a function factory.\n\n::: {.cell}\n\n```{.r .cell-code}\nis_function_type_factory = function(pattern, fixed=TRUE){\n    force(fixed) # force evaluation\n\n    function(x){\n        if(!is.function(x))\n            return(FALSE)\n        \n        body = body(x)\n        if(is.null(body))\n            return(FALSE) # primitives don't have body\n\n        deparse(body) |> grep(pattern=pattern, fixed=fixed) |> any()\n        }\n    }\n\nis.internal = is_function_type_factory(\".Internal\")\nis.external = is_function_type_factory(\".External\")\nis.ccall    = is_function_type_factory(\".C\") # will match .C and .Call\nis.fortran  = is_function_type_factory(\".Fortran\")\n\n# Get all functions from base, we did this before\nfunctions = Filter(is.function, sapply(ls(baseenv()), get, baseenv()))\n```\n:::\n\nSo out of 1242, there are 185 primitives, 415 internals, 0 external calls, 3 calls using the `.C` or `.Call` interface, 6 calls to Fortran, with the rest being pure R functions.\n\n### Primitives\nPrimitives are special functions that form the core of R language. Normal functions (called *closures* in R) have a list of arguments called *formals*, a *body*, and an enclosing *environment* (thus called *closures*).\n\n::: {.cell}\n\n```{.r .cell-code}\n# formals, body and environment of `is.internal`\nnot_null = Negate(is.null)\nhas_fbe = function(x){c(\n    \"formals\"     = formals(x) |> not_null(),\n    \"body\"        = body(x) |> not_null(),\n    \"environment\" = environment(x) |> not_null()\n    )}\n    \nhas_fbe(is.internal)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    formals        body environment \n       TRUE        TRUE        TRUE \n```\n:::\n:::\n\nCompared to normal functions, primitives do not have any *formals*, *body*, or enclosing *environment*.\n\n::: {.cell}\n\n```{.r .cell-code}\nhas_fbe(`-`)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    formals        body environment \n      FALSE       FALSE       FALSE \n```\n:::\n:::\n\n\nThis is why we put an additional check for `body(x) |> is.null()` in our function factory.\nSo what about the printed body of `-` that we saw before? It was a fake! R is lying to us here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`-` # output of this is fake\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (e1, e2)  .Primitive(\"-\")\n```\n:::\n:::\n::: {.cell}\n\n```{.r .cell-code}\nminus = function(e1, e2) .Primitive(\"-\")\nminus\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction(e1, e2) .Primitive(\"-\")\n```\n:::\n:::\n\nSee the extra space in the original `-`? Now watch this. Calling `minus(1,2)` just prints the original `-`.\n\n::: {.cell}\n\n```{.r .cell-code}\nminus(1,2) # just prints the original `-`\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (e1, e2)  .Primitive(\"-\")\n```\n:::\n:::\n\nTo get the correct result, we need to call `minus()(1,2)`.\n\n::: {.cell}\n\n```{.r .cell-code}\nminus()(1,2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1\n```\n:::\n:::\n\nThis is because our function returns the `.Primitive(\"-\")` which then performs the actual call to the `-` primitive.\n\nAll the special language elements like `for`, `(` are primitives, so are the functions like `.Internal` or `.Call` that communicate with the internal or external libraries. Finally, there is also a performance consideration, many non-special functions are primitives because these call need to be performant.\n\n### Generics\nOne reason why I am talking about these types of functions is because of generics.\nGenerics^[For a more broad description of related ideas, see [https://en.wikipedia.org/wiki/Generic_programming](https://en.wikipedia.org/wiki/Generic_programming)] are types of functions that when called, they dispatch a function specific to the type of input object. Typically, the type of object is called a *class*, and the specific function is called a *method*. This is the core of the S3 object-oriented system. For instance, in most cases you don't need to worry what kind of object you are working with and call `print` anyway, which will then dispatch an appropriate method based for the class of the object, such as `print.data.frame` or `print.Date`. This makes interactive use quite convenient, but also allows you to write a more generic code.\nFor instance, instead of having to expect every single possible class in your function, you can rest assured that `as.character` will provide you a reasonable output.\n\nTypical S3 generic functions would look like this:\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, ...) \nUseMethod(\"print\")\n<bytecode: 0x558f238a6c58>\n<environment: namespace:base>\n```\n:::\n:::\n\nJust a single call to `UseMethod(\"print\")` alternatively `UseMethod(\"print\", x)` to make the object for which the method will be dispatched (`x` in this case) explicit. Notice that no other argument parsing is happening there, this is done behind the curtain.\n\n### Generic primitives\nPrimitives can be generics as well, even without the use of `UseMethod`.\nThere are a few ways how this is achieved.\n\nFirst of all, there are S3 prototype functions in the `.GenericsArgsEnv` environment.\nThey look like your standard S3 generic function, just a call to `UseMethod`.\n\n::: {.cell}\n\n```{.r .cell-code}\nget_objects = function(x){\n    if(is.character(x))\n        x = getNamespace(x)\n\n    sapply(x |> ls(), get, x)\n    }\n\nprimitive_generics = get_objects(.GenericArgsEnv)\nprimitive_generics[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`-`\nfunction (e1, e2) \nUseMethod(\"-\")\n<bytecode: 0x558f21115ed8>\n<environment: namespace:base>\n```\n:::\n\n```{.r .cell-code}\nprimitive_generics |> names() |> head(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"-\"   \"!\"   \"!=\"  \"*\"   \"/\"   \"&\"   \"%/%\" \"%%\"  \"^\"   \"+\"  \n```\n:::\n:::\n\nHowever, I am not sure if they are actually used during calls or are there for other reason, such as documentation. There is a similar environment `.ArgsEnv` that contains primitives that are not generics.\n\n::: {.cell}\n\n```{.r .cell-code}\nprimitive_not_generic = get_objects(.ArgsEnv)\n\nprimitive_not_generic[[\"seq_len\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (length.out) \nNULL\n<bytecode: 0x558f21104b30>\n<environment: namespace:base>\n```\n:::\n:::\n\nThese functions, when executed, just return `NULL`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprimitive_not_generic[[\"seq_len\"]](5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\nCompare this to a standard call to `seq_len`\n\n::: {.cell}\n\n```{.r .cell-code}\nseq_len(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\nThis suggests that these functions, likely both `.GenericsArgsEnv` and `.ArgsEnv` are not involved in the function dispatch, or if they are, they are involved much later after the `.Primitive()` call is evaluated.\n\nThis brings us to the second way how primitives can be generic.\nBut this dispatch is being performed directly in the internal C code using either the `DispatchOrEval` call or `DispatchGeneric`. I will stop here and won't got deeper, because the situation is quickly getting complicated. For instance, despite the manual saying that something called group generics are using the `DispatchGeneric`, this is not actually the case and this function doesn't exist in the C code. Instead, many generics are grouped, thus *called group*, have a complex system of dispatching based utilizing `DispatchGroup` (instead of `DispatchGeneric`), `switch` and integer values likely related to the functions in the `src/main/names.c` source code.\n\nYou can see which functions are *group generics* in two ways, reading the help file for `?groupGeneric` (it has no associated object) or by removing non-group generic functions from all primitive generics:\n\n::: {.cell}\n\n```{.r .cell-code}\nsetdiff(primitive_generics |> names(), .S3PrimitiveGenerics)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"-\"        \"!\"        \"!=\"       \"*\"        \"/\"        \"&\"       \n [7] \"%/%\"      \"%%\"       \"^\"        \"+\"        \"<\"        \"<=\"      \n[13] \"==\"       \">\"        \">=\"       \"|\"        \"abs\"      \"acos\"    \n[19] \"acosh\"    \"all\"      \"any\"      \"Arg\"      \"asin\"     \"asinh\"   \n[25] \"atan\"     \"atanh\"    \"ceiling\"  \"Conj\"     \"cos\"      \"cosh\"    \n[31] \"cospi\"    \"cummax\"   \"cummin\"   \"cumprod\"  \"cumsum\"   \"digamma\" \n[37] \"exp\"      \"expm1\"    \"floor\"    \"gamma\"    \"Im\"       \"lgamma\"  \n[43] \"log\"      \"log10\"    \"log1p\"    \"log2\"     \"max\"      \"min\"     \n[49] \"Mod\"      \"prod\"     \"range\"    \"Re\"       \"round\"    \"sign\"    \n[55] \"signif\"   \"sin\"      \"sinh\"     \"sinpi\"    \"sqrt\"     \"sum\"     \n[61] \"tan\"      \"tanh\"     \"tanpi\"    \"trigamma\" \"trunc\"   \n```\n:::\n:::\n\nNote that these lists of functions are not generated from the C source code, so there is no way other than reading the C source code to know if a primitive function is generic or not.\n\n### Operator overloading\nEquations would be quite messy if you had to write a different `+` for scalars, vector and matrices. In case of operators, this is called [operator overloading](https://en.wikipedia.org/wiki/Operator_overloading) and can be a dangerous tool if not done carefully.\n\nThe whole point of operator overloading is that you can have quite complex objects and operate with them in a nice and polite manner as long as the semantics of operators make sense. For instance, the `Matrix` package defines sparse matrices. Sparse matrices are matrices where the majority of elements are equal to zero. Because of this, it is quite a bit more efficient if they are respresented not as a standard matrix with `n*m` elements, but with a special representation where you represent only elements that are non-zero. This saves memory and makes some operations faster. At the same time, you want them to behave like standard matrices with operations like addition, multiplication, or subsetting. So in standard S3 way (or S4 in this case), you overload the `+` operator to dispatch a particular function for addition of two standard matrices, one standard and one sparse, or two sparse matrices. From user perspective, nothing has changed and the operation looks the same `M + N` regardless of what types the matrices are summed. In languages like Java, which forgeos operator overloading in favour of heavy object-oriented system, you would have to do something of this sort:\n\n```\n# without operator overloading\nM.add(N)\n```\nYou can see that complex equation might look quite messy due to this. At least Java has [function overloading](https://en.wikipedia.org/wiki/Function_overloading).\nWithout that, you would have to detect the particular type of objects and dispatch an appropriate function by yourself. This is exactly what the R source code written in C has to do.\n\nNote that this operator overloading does not always work and you can't easily overload operators for basic types. For instance, some languages like to overload the `+` operator for the addition of strings, performing string concatenation. This makes sense in some cases, doesn't in other cases and is another contentious problems, there is a whole discussion about this on the [R mailing list](https://www.stat.math.ethz.ch/pipermail/r-devel/2006-August/038991.html).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`+.character` = function(x,y){paste0(x,y)}\n\"foo\" + \"bar\"\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in \"foo\" + \"bar\": non-numeric argument to binary operator\n```\n:::\n:::\n\nThis is `character` is a basic type, which do not have a class and thus do not immediatelly work with all primitive generics this way. What matters here is the attribute `class` that is added to S3 objects. But if you try to explore this attribute with the `class()`, R will lie to you. You need to use the `oldClass()` function to see the S3 attribute.\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(\"foo\") # will lie to you\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\noldClass(\"foo\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\nThis overloading will work well for user-defined S3 classes.\n\n::: {.cell}\n\n```{.r .cell-code}\n`+.foobar` = function(x,y){paste0(x,y)}\nstructure(\"foo\", class = \"foobar\") + structure(\"bar\", class = \"foobar\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"foobar\"\n```\n:::\n:::\n\n\nOr you can define the class explicitelly as a `character`.\n\n::: {.cell}\n\n```{.r .cell-code}\n`+.character` = function(x,y){paste0(x,y)}\nstructure(\"foo\", class = \"character\") + structure(\"bar\", class = \"character\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"foobar\"\n```\n:::\n:::\n\nBut it is better to not due this.\n\nAnother way is to overwrite the `+` function with user-defined function, but don't do this either.\nIf you think that the `+` semantics makes sense for strings, just define the `%+%` operator:\n\n::: {.cell}\n\n```{.r .cell-code}\n`%+%` = function(x,y){paste0(x,y)}\n\"foo\" %+% \"bar\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"foobar\"\n```\n:::\n:::\n\n\nOne famous case of using the operator `+` in a special way is to combine graphical elements in the `ggplot` package. \n\nOperator overloading is especially useful for the equality operator `=`, but also for various subsetting operators `[` or `[[`, as well as for the replacement operators `[<-`. We will talk about this next time.\n\n### special vs builtin\nAnd just for completeness, Primitives and internal functions are also divided into *special* and *builtin*.\n\n::: {.cell}\n\n```{.r .cell-code}\nprimitives = Filter(is.primitive, functions)\nsplit(primitives |> names(), sapply(primitives, typeof)) |>\n    sapply(head, n=10, simplify=FALSE) # sample of bultin and specials\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$builtin\n [1] \"-\"   \":\"   \"!\"   \"!=\"  \"(\"   \"*\"   \"/\"   \"&\"   \"%*%\" \"%/%\"\n\n$special\n [1] \"::\"   \":::\"  \"[\"    \"[[\"   \"[[<-\" \"[<-\"  \"{\"    \"@\"    \"@<-\"  \"&&\"  \n```\n:::\n:::\n\nThe difference between them is that *builtin* functions evaluate all their arguments before being passed to the internal implementation, while *special* don't evaluate their arguments.\nWhen profiling, *builtin* functions are also counted as a function calls, while *special* aren't.\nOnly a small number of functions are trully special :). And while we can look which primitives are builtin or special, we can't do so with internal functions. For instance, according to the documentation, `cbind` is special internal, while `grep` is builtin internal.\nBut when you to get their type, all you get is a `closure`.\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"cbind\" = typeof(cbind), \"grep\" = typeof(grep))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    cbind      grep \n\"closure\" \"closure\" \n```\n:::\n:::\n\nUnless you want to join the development team of R, you do not need to know about this distinction.\n\n## Summary\nEverything that happen in R is a function call, but for performance and parsing purpose, R has different types of functions. The classic functions in R are *closures*, but there are special kind of functions called *primitives*. Most operators are primitives and some primitives can also be generics, which connects them to the S3 dispatch system. This allows operators to be overloaded for user-defined classes, but not for basic types, despite not being typical S3 generics with `UseMethod()` call.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}