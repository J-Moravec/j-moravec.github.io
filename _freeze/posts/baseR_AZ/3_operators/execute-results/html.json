{
  "hash": "d5ca1473a3d4545669961a58d965e1b9",
  "result": {
    "markdown": "---\ntitle: \"Base R from A to Z: Operators (3)\"\ndescription: \"Arithmetic, Logical and Relational operators\"\ndate: \"2023-03-04\"\ncategories: [R]\ntoc: true\ntoc-depth: 4\n---\n\n\n## Introduction\n\nIn the third part of the series about base R, we will talk about **operators**.\nAs we have mentioned in the previous part, operators are construct similar to functions, but with special syntax or semantics. While you can call them as a functions, and there are instances where you want to do that, normally you call them in a special way called *infix* notation.\n\n::: {.callout-note}\n### Infix, prefix and postfix\nMost of us are used to the classical *infix* notation, such as `3 + 5`. However, in some older programming languages, there is also a *prefix* notation ` + 3 5` and postfix notation `3 5 +`. These can be efficiently parsed using a *stack*, and do not require operator precedence.\n\nTechnically, R contains a traces of *prefix* notation in the form `\"+\"(3,5)` (or in fact, any functional call), but unlike in the typical prefix or postfix languages, the parentheses are required. Additionally, `!` is unary, and `-` and `+` have unary form, so they can be considered prefix, such as `-8` or `!a`.\n\nFor more information, see [infix](https://en.wikipedia.org/wiki/Infix_notation), [prefix](https://en.wikipedia.org/wiki/Polish_notation) and [postfix](https://en.wikipedia.org/wiki/Reverse_Polish_notation) on Wikipedia.\n:::\n\nR offers a multitude of operators and a way to define new operators through the `%any%` notation.\nOperators can be divided into these groups:\n\n* Arithmetic operators  \n    `+`, `-`, `*`, `/`, `^`, `%%`, `%/%`\n* Logical operators  \n    `!`, `&`, `&&`, `|`, `||`\n* Relational operatos  \n    `<`, `>`, `<=`, `>=`, `==`, `!=`\n* Subsetting operators  \n    `[`, `[[`, `@`, `$`\n* Assignment operators  \n    `<-`, `<<-`, `=`, `[<-`, `[[<-`, `@<-`, `$<-`\n* Matrix operators  \n    `%*%`, `%o%`, `%x%`\n* Special operator  \n    `%anything%`\n* Matching operator  \n    `%in%`\n* Sequence operator  \n    `:`\n* Operators in formula:\n    `~`, `:`, `%in%`\n* Namespace access:\n    `::`, `:::`\n* Parentheses and braces  \n    `(`, `{`\n\nWe will talk about Arithmetic, Logical, Relational, Subsetting, Assigment and Matrix operators, as well as the special operator `%anything%`. Matching operator is just a shorthand for the `match()` function, so we will leave it for later. The sequence operator `:` is a primitive for performance (and parsing) reasons, but we will talk about it together with other sequence-generating functions. The `::` and `:::` are quite complex, so we will talk about them when we go deeper into environments, namespaces and package access, and the `(` and `{` are language features rather than operators or functions, so we skip them for later. Finally, the `?` operator is not part of the *base*, but is in *utils*.\n\n## Operator precedence\nFrom basic mathematics, we are used to the idea that multiplication precedes addition, so `3 + 5 * 2` is interpreted as `3 + (5 * 2)` without having to use parentheses. These rules are called *operator precedence*. Here I am reproducing the list from the `?Syntax` help command.\n\nFor listed operators, precedence goes from highest (evaluated first) to lowest.\nOperators with the same precedence are evaluated in the order they are encountered.\n\n* `::`, `:::`\n* `$`, `@`\n* `[`, `[[`\n* `^`\n* `-`, `+` in their unary form (`-3`, `+5`)\n* `:`\n* `%any%`, `|>` (base R pipe)\n* `*`, `/`\n* `+`, `-` in their binary form (`3+5`)\n* `<`, `>`, `<=`, `==`, `!=`\n* `!`\n* `&`, `&&`\n* `|`, `||`\n* `~`\n* `->`, `->>`\n* `<-`, `<<-`\n* `=`\n* `?`\n\nNow for some interesting consequences. With `^` having such high precedence, `-a^2` is interpeted as `-(a^2)` instead of `(-a)^2`, but then `-1:3` is interpeted as `(-1):3` and not `-(1:3)`.\n\nThe pipe `|>` has high precedence, which mean you can't do `a + 2 |> ...`, because it is interpeted as `a + (2 |> ...)`. This bites me all the time, when I just want to do some simple division or addition inside pipes.\n\nFinally `=` has lower precedence than `<-`. This shouldn't be an issue since you should use either `=` or `<-` as your assignment operator.\n\nThe takeway is that you should not rely on common sense your knowledge of operator precedence rules, but use parentheses to make operations as much explicit as possible.\n\n## Arithmetic operators\nArithmetic operators are addition `+`, subtraction `-`, multiplication `*`, division `/`, exponentiation `^`, modulo `%%` and integer division `%/%`.\n\nThe addition, subtraction, multiplication, division, and exponentiation are well known.\nModule and the integer division are less common, but occasionaly useful in programming.\nModulo `%%` is the remainder after integer division, so that `5 %% 2 = 1`. The `%/%` is the integer division `5 %/% 2 = 2`. These are used when we want to know how many times something fit in our number, if we need to do something with a certain frequency, or if you want to know if a number is even. But arguably, some of these are displaced by sequence functions, and if we want to fit `k` elements into categories of size `m`, `ceiling(k/m)` gives us exactly that. So personally, I haven't used modulo or integer division very often.\n\nThe `+` and `-` operators can be both unary and binary, meaning they accept one or two parameters. The meaning and behaviour, such as operator precedence, are different for the unary and binary version.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n+ a # unary `+`\n- a # unary `-`\n\na + b # binary `+`\na - b # binary `-`\n```\n:::\n\n\nThis is related to how numbers are parsed by the interpreter (see [literals](https://en.wikipedia.org/wiki/Literal_(computer_programming)). Details are not important, just remember that the unary and binary operators are different, and that the unary `-` makes numbers negative. Fun fact, as a consequence of the parsing rules, this is valid R code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n+ - + - 5 + - + - + + - - + - 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\nAs with most fun facts, you should not ever write a code like this.\n\n::: {.callout-note}\n### Recycling\nA lot of basic operations in R do something called *recycling*. For instance, when you add together two vectors with a different number of elements, the shorter vector is being extended by reusing (recycling) its elements.\n\nFor instance, consider multiplying a vector of length 3 with a vector of length 1: `c(1, 2, 3) * 3`. This is identical to `c(1,2,3) * c(3, 3, 3)` because the shorter vector is being recycled. This work well when the length of the longer vector is a multiple of the shorter vector (i.e., `longer %% shorter = 0`), for instance:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, 3, 4, 5, 6) + c(1, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 4 6 6 8\n```\n:::\n:::\n\nYou can see that the shorter vector was recycled as `c(1,2, 1,2, 1,2)`, because the length of the longer vector is a multiple of the shorter one. If this is not the case, the shorter vector is still recycled, but a warning is thrown.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1,2,3) * c(1,2)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in c(1, 2, 3) * c(1, 2): longer object length is not a multiple of\nshorter object length\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 4 3\n```\n:::\n:::\n\n\nRecycling allows you to do some fancy tricks, for example if you want to pick every second element of a vector:\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1,2,3,4,5,6)[c(FALSE, TRUE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 6\n```\n:::\n:::\n\n\nThis works because the selection vector is being recycled to the full length using the predefined pattern.\n\n:::\n\n#### The strange case of **\nIn some languages such as Python, `**` is a power operator. This is also supported in R:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 ^ 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n\n```{.r .cell-code}\n2 ** 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n:::\n\nStrangely, `**` is not documented, `**` is not a primitive, and when you type bare `**` in R, you will get a curious error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n**\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: <text>:1:1: unexpected '^'\n1: **\n    ^\n```\n:::\n:::\n\n\nThere is a small note in the `?Arithmetic`. Apparently, `**` existed in S (the precedesors of R) but was deprecated. For backward compatibility, the R parser kept this functionality and translates `**` into `^`. Since it is undocumented and not part of the official language specification, do not use `**`.\n\n## Logical operators and functions\nSince we are already talking about the logical operators, I thought it might be more useful to look more closely at the *logical* type and functions that operate with it.\n\nLogical operators are negation `!`, which is a unary operator, and binary logical *and* `&` and `&&`, logical *or* `|` and `||`. Aside of these operators, there is also a function `xor()`, helpers `isTRUE()`, `isFALSE()`, useful primitives `all()` and `any()`, and functions for the creation, testing, and conversion to the *logical* type: `logical()`, `is.logical()`, and `as.logical()`.\n\n### Logical operators\nLogical operators are negation `!`, logical *and* `&`, `&&`, and logical *or* `|`, `||`.\n\nThe negation `!` operator just makes a `FALSE` value `TRUE` and the other way around. The *and* and *or* operators are more interesting in the way they work on vectors.\n\nThe single symbol *and* and *or* operators `&` and `|` work like `+` or `-`, they are applied element-wise and vectors are recycled as required.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(TRUE, TRUE, FALSE) & c(TRUE, FALSE, FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\nc(TRUE, TRUE, FALSE) | c(TRUE, FALSE, FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE FALSE\n```\n:::\n:::\n\n\nThe double-symbol *and* and *or* are not vectorized, they uses only the first element of a vector, while other elements are ignored. Likewise, the output of `&&` and `||` is a single `TRUE` or `FALSE` value.\nThis makes `&&` and `||` useful when doing control flow operations with `if(condition){...}`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(TRUE, TRUE) && c(TRUE, FALSE) # only the first value is used\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n#### Short-circuting\nIn addition, the `&&` and `||` [short-circuits](https://en.wikipedia.org/wiki/Short-circuit_evaluation), the second expression is evaluated only if it is required. For instance, in the expression:\n\n```\na || b\n```\nIf `a` evaluates to `TRUE`, the whole expression evaluates to `TRUE` regardless of `b`.\nThis means that if `a = TRUE`, `b` doesn't have to be evaluated and in fact isn't evaluated.\nSo if the `b` was a function call with some side effects, the side effects (reading file, printing, increasing a counter) are never evaluated. For instance, consider an expression that prints `foo` and returns `TRUE`:\n\n```\n{print(\"foo\"); TRUE}\n```\n\nIf we use two of these expression with `||`, only single `foo` will be printed:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n{print(\"foo\"); TRUE} || {print(\"foo\"); TRUE}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"foo\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nContrast this with the `&` or `|` which do not short-curcuit:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n{print(\"foo\"); TRUE} | {print(\"foo\"); TRUE}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"foo\"\n[1] \"foo\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nIn some languages, this is used as a control structure, since this behaviour can be transformed into:\n\n```\nif a then a, else b\n```\n\nBut I haven't seen this being used in R.\nSince the R code is typically light on side-effects, I don't think there is a much value in trying to be cheeky in this way.\n\n#### NA behaviour\n`NA` or *not available* is a peculiar value (or values, since there is `NA_character_`, `NA_integer_` atp.) that symbolize a missing value. Most programing languages do not have this (usually, they only have `NULL`), but R was designed as a domain-specific language for data-analysis and unknown values are a common problem.\n\nTypically, any numerical calculation involving `NA` typically results in `NA`.\n\n::: {.cell}\n\n```{.r .cell-code}\n3 + NA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n```{.r .cell-code}\n5 * NA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nLogical operations are slightly different and result in `NA` only if the expression depends on it.\nYou can intepret this dependence in a similar manner as short-circuting, but this works even for the non-short-circuiting operators `|` and `||`.\n\nFor example, in the `x | NA`, if `x` is `TRUE`, the whole expression is also `TRUE`. But if `x` is `FALSE`, the whole expression depends on the unknown value `NA`, which means that the expression evaluates to `NA`.\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE | NA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nFALSE | NA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nSimilarly, in the `x & NA`, if `x` is `FALSE`, the whole expression is `FALSE`. But if `x` is `TRUE`, the result of the expression depends on the `NA` and the expression evaluates to `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nFALSE & NA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nTRUE & NA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nIn the same manner, the `!NA` depends on the `NA` so it evaluates to `NA` and so on.\n\n### Logical functions\nNow, lets move to the functions. The `isTRUE()` and `isFALSE()` are also useful shorthands for control flow.\nThey detect if the condition is exactly `TRUE` or `FALSE` respectively, a good way to avoid pitalls with `NA`, `NULL`, which might arise from some operations and should be processed appropriatelly.\n\nThe logical operations `xor()` is elementwise exclusive *or*. It is not an operator, and not a primitive, likely because it is not used very often. You can see that `xor()` is just a shorthand for `(x | y) & !(x & y)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxor\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, y) \n{\n    (x | y) & !(x & y)\n}\n<bytecode: 0x55a87771d0f8>\n<environment: namespace:base>\n```\n:::\n:::\n\n\nVery useful if *only* x *or* y are allowed, such as if you are using parameters as a mutually exclusive flags. Consider a function that does either `foo` or `bar`, but can't do both at the same time:\n\n```\nmyfunc = function(x, doFoo=FALSE, doBar=FALSE){\n    if(!xor(doFoo, doBar))\n        stop(\"Must select either doFoo or doBar\")\n\n    if(doFoo)\n        return(foo(x))\n    if(doBar)\n        return(bar(x))\n    }\n```\nWithout `xor`, the function might not behave as expected, not returning anything if either both conditions are `FALSE`, or performing only one operation if both conditions are `TRUE`.\n\nYou can turn `xor()` easily into an *infix* operator `%xor%`.\n\n::: {.cell}\n\n```{.r .cell-code}\n`%xor%` = xor\nTRUE %xor% FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nBefore we start talking about the `logical` type in general, lets quickly mention the `all()` and `any()`. These are vectorized and will tell you if *all* or *any* value of the vector are `TRUE` respectively. For efficiency reason, they are primitives, because they are used quite often for the control flow.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec = c(TRUE, TRUE, FALSE)\nall(vec) # will be FALSE because not all values are TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nany(vec) # TRUE as at least one value is TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nYou can define a vectorized variant of `xor` which tells you that there is exactly one `TRUE` rather easily:\n\n\n::: {.cell}\n\n```{.r .cell-code}\none = function(x){\n    sum(x, na.rm=TRUE) == 1\n    }   \none(c(TRUE, TRUE, FALSE)) # will be FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\none(c(FALSE, TRUE, FALSE)) # will be TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n### Conversion rules\n\nThis brings us to an important step, conversion. You can apply logical operators not only on the logical `TRUE` and `FALSE` values, but as with many similar operations in R, the values are automatically converted to the correct type.\n\nConversion is performed internally using the `as.logical` primitive. Valid conversions are from `numeric` (that is, both `integer` and `double`), `complex`, and `character`. For the `numeric` and `complex`, `0` is converted into `FALSE` and non-zero value is converted into `TRUE`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.logical(0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nas.logical(5i+3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\nFor the character type, the conversion is a bit more complex. The strings \"T\", \"TRUE\", \"True\" and \"true\" are converted into `TRUE`, and similarly \"F\", \"FALSE\", \"False\" and \"false\" are converted into `FALSE`. Everything else, including \"TrUe\" and similar messy capitalizations, is converted into `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.logical(c(\"T\", \"TRUE\", \"True\", \"true\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE TRUE TRUE TRUE\n```\n:::\n\n```{.r .cell-code}\nas.logical(c(\"F\", \"FALSE\", \"False\", \"false\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\nas.logical(c(\"1\", \"0\", \"truE\", \"foo\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA NA NA\n```\n:::\n:::\n\n\nThe `logical(n)` is a shorthand for `vector(\"logical\", n)` and simply create a logical vector of length `n` with values initialized to `FALSE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogical(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE FALSE FALSE\n```\n:::\n:::\n\n\nWhen converting from logical to numeric, the `TRUE` and `FALSE` converts to `1` and `0` respectively. This allows for the convenient use of `sum` or `mean` to count the number or the percentage of matches. When converting from logical to character, the `TRUE` and `FALSE` gets converted simply to `\"TRUE\"` and `\"FALSE\"` strings.\n\n### Raw vectors\nThe logical operators `!`, `&` and `|` have another meaning for raw vectors.\n`raw` is a basic type, alongside `integer`, `double`, `list`, and so on.\nIt represents raw bytes (from 0 to 255), here printed in a hexadecimal format:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.raw(c(0, 10, 255))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 00 0a ff\n```\n:::\n:::\n\n\nFor these raw vectors, the logical operators have a slightly different bitwise meaning.\nSee `bitwNot`, `botwAnd`, and `bitwOr` for `!`, `&`, and `|` respectively.\nWe will talk in-depth about raw type and operations on them later in this series.\n\n## Relational operators\nRelational operatos are _smaller than_ `>`, _larger than_ `>`, _smaller or equal_ `<=`, _larger or equal `>=`, equal `==`, and not equal `!=`. For `numeric` (`integer` and `double`) and `logical` (which is converted to numeric), the comparisons are what you might expect, just a standard numerical comparisons.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5L > 2L # integers, the `long` type\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n5.3 > 2.8\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nTRUE > FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nFor `raw`, the numeric order is used so the comparisons also behaves as expected, and for `complex`, only the `==` and `!=` comparisons are implemented.\n\n::: {.cell}\n\n```{.r .cell-code}\nas.raw(5) > as.raw(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n5+1i > 2+1i\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in 5 + (0+1i) > 2 + (0+1i): invalid comparison with complex values\n```\n:::\n:::\n\n\n### String comparisons \nFor `character` strings, the comparisons are quite a bit more complicated. If you consider only standard english alphabet, the problem might feel obvious. But every language has slightly different rules about order of character in their alphabet. Quoting from the R help page:\n\n> Beware of making _any_ assumptions about the\n> collation order: e.g. in Estonian ‘Z’ comes between ‘S’ and ‘T’,\n> and collation is not necessarily character-by-character - in\n> Danish ‘aa’ sorts as a single letter, after ‘z’.  In Welsh ‘ng’\n> may or may not be a single sorting unit: if it is it follows ‘g’.\n\nOn top of this, the order is system and locale dependent. This makes sorting extremely unpredictable when comparing strings accross languages.\n\nFor more information, see [Microsoft page](https://learn.microsoft.com/en-us/globalization/locale/sorting-and-string-comparison) or [long unicode explanation](http://unicode.org/reports/tr10/).\n\nI am happy that smarter people solved it and I don't need to know the details.\n\n### Floating point comparisons\nThere is a caveat when comparing `doubles`. You might remember that computers work in a binary. This means that every number is represented by combination of bits that can be `0` or `1`. You might start sensing that something is off in here. How can I represent a rational number by just combination of `0` and `1`? This is because computers are able to represent perfectly only whole numbers, `integer`. Anything else is represented imperfectly and you get rounding errors. R is trying to hide this imperfection by rounding when printing, but the abstraction will leak if you try to compare for equality.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(1 - 0.9)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1\n```\n:::\n\n```{.r .cell-code}\n(1 - 0.9) == 0.1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\nThe `>` and `<` still works as intended, but when you are comparing floating point numbers, use `all.equal` instead and select an appropriate precision (by default `sqrt(.Machine$double.eps)` is used):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall.equal( (1 - 0.9), 0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nUnlike with string comparison, this is common issue that will significantly influence the performance of your code, especially if you are writing any kind of numerical algorithm. You need to be aware of these issues. See [shorter explanation](https://floating-point-gui.de/) and [longer explanation](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html) and try to understand them.\n\n## Group generic methods and Ops\n\nSome methods are grouped into groups called *group generics* functions.\nThese methods are dispatched when any of the grouped functions are called.\nWhile it might look strange at first look, this allows for some neat tricks to efficiently define common mathematical operations for a large group of functions.\n\nFor instance, consider `Ops.POSIXt` which defines *arithmetic*, *logical* and *relational* operators for the S3 class `POSIXt`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nOps.POSIXt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (e1, e2) \n{\n    if (nargs() == 1L) \n        stop(gettextf(\"unary '%s' not defined for \\\"POSIXt\\\" objects\", \n            .Generic), domain = NA)\n    boolean <- switch(.Generic, `<` = , `>` = , `==` = , `!=` = , \n        `<=` = , `>=` = TRUE, FALSE)\n    if (!boolean) \n        stop(gettextf(\"'%s' not defined for \\\"POSIXt\\\" objects\", \n            .Generic), domain = NA)\n    if (inherits(e1, \"POSIXlt\") || is.character(e1)) \n        e1 <- as.POSIXct(e1)\n    if (inherits(e2, \"POSIXlt\") || is.character(e2)) \n        e2 <- as.POSIXct(e2)\n    check_tzones(e1, e2)\n    NextMethod(.Generic)\n}\n<bytecode: 0x55a877002078>\n<environment: namespace:base>\n```\n:::\n:::\n\n\nFirst, the function checks if only a single argument was passed, because unary operators are not defined.\n\nThen it uses `switch` statement, which evaluates to `TRUE` if one of `<`, `>`, `==`, `!=`, `<=`, and `>=` matches the `.Generic` variable, which is an automatic variable initialized to the dispatched generics from the `Ops` group. So if the function call was `!POSIXt`, the `.Generic` is the negation operator `!`. The `switch` statement thus works as a check whether a particular operator makes sense for the class, throwing error if the operation was not defined.\n\nThis doesn't mean that operators not specified in the switch are undefined. In fact, both `+.POSIXt` and `-.POSIXt` exists.\n\n::: {.callout-note}\n### POSIXt, POSIXlt and POSIXct\nR contains a number of different classes for dates. \n\n`POSIXct` is a signed number of seconds since the begining of 1970 (UCT time zone), the [Unix time](https://en.wikipedia.org/wiki/Unix_time).\n\n`POSIXlt` is a named list of vectors with `sec`, `min`, `hour`, `mday` and so on.\n\n`POSIXct` is a really simple and convenient way to keep time, but not very human readable (unless you are Unix guru). `POSIXlt` is a nice human-readable format, but not very convenient when you want to store precise times in a `data.frame`\n\n`POSIXt` is a virtual class, both `POSIXct` and `POSIXlt` inherits from it. This means that when you define a method for `POSIXt`, it will automatically work for `POSIXct` and `POSIXlt`.\n:::\n\nSince `POSIXt` is a virtual class, and math with a number of seconds `POSIXct` is simpler than math on a complex data structure `POSIXlt` (see the box), what follows is a conversion into `POSIXct`, and the call to `NextMethod()`, which simply calls the appropriate method for the `.Generic` on the modified parameters. There is nothing simple on `NextMethod()` and we will talk about it later, when we are talking in-depth about the S3 system.\n\n### Double dispatch\n\nMethods in the `Ops` group are special because most of them are binary and they need to do something called [double dispatch](https://en.wikipedia.org/wiki/Double_dispatch). For instance, if you are adding objects of class `foo` and `bar`, you need to dispatch the correct method for this particular addition, taking in account classes of both objects, not just `foo` or `bar` independently. To keep addition comutative, method needs should be identical even if the order of addition is changed (`bar + foo`).\n\nS3 has rather primitive double-dispatch system, the rules are as follows:\n\n1) If neither objects has a method, use internal method.\n2) If only one object has a method, use that method.\n3) If both objects have a method, and the methods:\n    a) are identical, use that method.\n    b) are not identical, throw a warning and use internal methods.\n \nTo demonstrate this, we define a helper function and methods for the `+` generic for classes `foo` and `bar`. These simply return `NULL` and print a message, which will tell us which method was dispatched.\n\n::: {.cell}\n\n```{.r .cell-code}\n# helper to make object less wordy\nobj = function(class){\n    structure(1, class=class)\n    }\n`+.foo` = function(...){message(\"foo\")}\n`+.bar` = function(...){message(\"bar\")}\n```\n:::\n\n\nThe first rule is just a normal addition:\n\n::: {.cell}\n\n```{.r .cell-code}\n1 + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\nAccording to the second rule, the `+.foo` method is dispatched:\n\n::: {.cell}\n\n```{.r .cell-code}\n1 + obj(\"foo\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nfoo\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\nobj(\"foo\") + 1\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nfoo\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\nobj(\"foo\") + obj(\"baz\") # no method +.baz\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nfoo\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n\nAccording to the third rule, since methods are not identical, we will get a warning.\n\n::: {.cell}\n\n```{.r .cell-code}\nobj(\"foo\") + obj(\"bar\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Incompatible methods (\"+.foo\", \"+.bar\") for \"+\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\nattr(,\"class\")\n[1] \"foo\"\n```\n:::\n\n```{.r .cell-code}\nobj(\"bar\") + obj(\"foo\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Incompatible methods (\"+.bar\", \"+.foo\") for \"+\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\nattr(,\"class\")\n[1] \"bar\"\n```\n:::\n:::\n\n\nFinally, if we redefine the `+.foo` and the `+.bar` to be identical, addition works again:\n\n::: {.cell}\n\n```{.r .cell-code}\n`+.foo` = function(...){message(\"foobar\")}\n`+.bar` = function(...){message(\"foobar\")}\nobj(\"foo\") + obj(\"bar\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nfoobar\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n\nNotice that if one of the object doesn't have defined an S3 method, we can make the S3 method that is dispatched quite complex and built-in support for different types. But this mechanism will be fragile and once someone defines method for one of the supported types, our method would be ignored and the dispatch would default to an internal method (with warning). For an explicit double dispatch system that can be further extended, we would need to go for S4 classes.\n\n## Example: sparse_vector\n\nAs an example, we will create an S3 class `sparse_vector`. There is an S4 class in the `Matrix` package, which is a more reasonable choice since S4 methods can be extended, but we do this only for demonstration purposes.\n\nFirst, we will define our class, sparse vector is defined by the vector of values `x`, vector of indices `i` and the length of the vector. Normally, we would make a barebone `new_sparse_vector` constructor, and the `sparse_vector` one would be an interface that would also check validity of input parameters, but we will keep it simple.\n\nWe also create a method for the `as.vector` generics, so that we can easily unroll our sparse vector into a normal one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsparse_vector = function(x, i, length){\n    structure(list(\n        x = x,\n        i = i,\n        length = length\n        ), class = \"sparse_vector\")\n    }\n\nas.vector.sparse_vector = function(x, ...){\n    y = vector(mode=mode(x$x), length=x$length)\n    y[x$i] = x$x\n    y\n    }\n\nprint.sparse_vector = function(x, ...){\n    y = rep(\".\", x$length)\n    y[x$i] = as.character(x$x)\n    print(y, quote=FALSE)\n    }\n\na = sparse_vector(c(3,5,8), c(2,4,6), 10)\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] . 3 . 5 . 8 . . . .\n```\n:::\n\n```{.r .cell-code}\nas.vector(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0 3 0 5 0 8 0 0 0 0\n```\n:::\n:::\n\n\nWe want to support all operations in the group generics `Ops`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nOps.sparse_vector = function(e1, e2){\n    if(inherits(e1, \"sparse_vector\"))\n        e1 = as.vector(e1)\n    # If Ops is unary, e2 is missing\n    if(!missing(e2) && inherits(e2, \"sparse_vector\"))\n        e2 = as.vector(e2)\n    NextMethod(.Generic)\n    }\n\na + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  2  5  2  7  2 10  2  2  2  2\n```\n:::\n\n```{.r .cell-code}\n2 + a\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  2  5  2  7  2 10  2  2  2  2\n```\n:::\n\n```{.r .cell-code}\na * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  0  6  0 10  0 16  0  0  0  0\n```\n:::\n\n```{.r .cell-code}\na == 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n```\n:::\n\n```{.r .cell-code}\n- a\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  0 -3  0 -5  0 -8  0  0  0  0\n```\n:::\n:::\n\n\nAnd essentially for free, we suddenly support all operations.\nBut this isn't very efficient if we are summing two sparse vectors, for instance.\nSo for some operations, we define their own functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`+.sparse_vector` = function(e1, e2){\n    message(\"+.sparse_vector dispatched\")\n    if(nargs() == 1L)\n        return(e1)\n\n    if(inherits(e1, \"sparse_vector\") && inherits(e2, \"sparse_vector\")){\n        i = union(e1$i, e2$i) |> sort()\n        j = intersect(e1$i, e2$i) |> sort()\n        l = max(e1$length, e2$length) # ignoring recycling for now\n        y = sparse_vector(rep(0, length(i)), i, l)\n        y$x[i %in% e1$i] = e1$x\n        y$x[i %in% e2$i] = e2$x\n        y$x[i %in% j] = e1$x[e1$i %in% j] + e2$x[e2$i %in% j]\n        return(y)\n        }\n    if(inherits(e1, \"sparse_vector\")){\n        e2[e1$i] = e2[e1$i] + e1$x\n        return(e2)\n        }\n    if(inherits(e2, \"sparse_vector\")){\n        e1[e2$i] = e1[e2$i] + e2$x\n        return(e1)\n        }\n    stop(\"This should be unreachable state\")\n    }\n\nb = sparse_vector(c(1, 2, 3), c(1, 4, 6), 10)\n+ a\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n+.sparse_vector dispatched\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] . 3 . 5 . 8 . . . .\n```\n:::\n\n```{.r .cell-code}\n+ b\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n+.sparse_vector dispatched\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 . . 2 . 3 . . . .\n```\n:::\n\n```{.r .cell-code}\na + b\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n+.sparse_vector dispatched\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1  3  .  7  .  11 .  .  .  . \n```\n:::\n\n```{.r .cell-code}\na + rep(1, 10)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n+.sparse_vector dispatched\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 4 1 6 1 9 1 1 1 1\n```\n:::\n\n```{.r .cell-code}\nb + rep(1, 10)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n+.sparse_vector dispatched\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 2 1 1 3 1 4 1 1 1 1\n```\n:::\n:::\n\n\nThe code isn't perfect, we ignore a lot of recycling, which means operations with matrices will not work correctly, and so on. But as an example of the `Ops` and operator overloading, this should be sufficient. One obvious improvement would be redefining the operator `[` to make subsetting of the vector much easier, and thus the code cleaner. We will look at this in the next article.\n\n## Summary\n\nIn this part, we have learned about operators, and more closely explored arithmetic, logical and relational operators. On top of this, we have learned more about group generic functions, double dispatch system, and managed to implement a simple `sparse_vector` class with working arithmetic, logical and relational operators.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}